//**** Cross-compiled for `masm` syntax from `tests/simplifier/conditional_borrow.move`

//# publish
// Bytecode version v8
module 0x8675::M
struct S has copy + drop
  f: u64

// Function definition at index 0
#[persistent] public fun test(): u64
    ld_u64 7
    call test1
    ld_u64 2
    call test1
    add
    // @5
    ret

// Function definition at index 1
fun test1(l0: u64): u64
    local l1: u64
    local l2: u64
    local l3: &mut u64
    local l4: u64
    local l5: u64
    local l6: u64
    local l7: u64
    local l8: u64
    copy_loc l0
    ld_u64 4
    lt
    br_false l0
    copy_loc l0
    // @5
    st_loc l1
l1: mut_borrow_loc l1
    st_loc l3
    ld_u64 10
    move_loc l3
    // @10
    write_ref
    move_loc l0
    st_loc l4
    mut_borrow_loc l4
    st_loc l3
    // @15
    copy_loc l3
    read_ref
    ld_u64 1
    add
    move_loc l3
    // @20
    write_ref
    move_loc l4
    st_loc l2
    copy_loc l2
    ld_u64 0
    // @25
    add
    st_loc l5
    mut_borrow_loc l5
    st_loc l3
    copy_loc l3
    // @30
    read_ref
    ld_u64 2
    add
    move_loc l3
    write_ref
    // @35
    copy_loc l2
    st_loc l6
    mut_borrow_loc l6
    st_loc l3
    copy_loc l3
    // @40
    read_ref
    ld_u64 4
    add
    move_loc l3
    write_ref
    // @45
    copy_loc l2
    st_loc l7
    mut_borrow_loc l7
    st_loc l3
    copy_loc l3
    // @50
    read_ref
    ld_u64 8
    add
    move_loc l3
    write_ref
    // @55
    copy_loc l2
    st_loc l8
    mut_borrow_loc l8
    st_loc l3
    copy_loc l3
    // @60
    read_ref
    ld_u64 16
    add
    move_loc l3
    write_ref
    // @65
    move_loc l2
    ret
l0: ld_u64 3
    st_loc l1
    branch l1

// Function definition at index 2
fun test1b(l0: S): u64
    local l1: S
    local l2: S
    local l3: &mut S
    local l4: S
    local l5: S
    local l6: S
    local l7: S
    local l8: S
    local l9: &mut u64
    local l10: S
    local l11: u64
    local l12: u64
    local l13: u64
    ld_u64 3
    pack S
    st_loc l1
    borrow_loc l0
    borrow_field S, f
    // @5
    read_ref
    ld_u64 4
    lt
    br_false l0
    copy_loc l0
    // @10
    st_loc l2
l1: mut_borrow_loc l2
    st_loc l3
    ld_u64 10
    move_loc l3
    // @15
    read_ref
    st_loc l4
    mut_borrow_loc l4
    mut_borrow_field S, f
    write_ref
    // @20
    move_loc l0
    st_loc l5
    mut_borrow_loc l5
    st_loc l3
    copy_loc l3
    // @25
    read_ref
    st_loc l6
    borrow_loc l6
    borrow_field S, f
    read_ref
    // @30
    ld_u64 1
    add
    move_loc l3
    read_ref
    st_loc l7
    // @35
    mut_borrow_loc l7
    mut_borrow_field S, f
    write_ref
    move_loc l5
    st_loc l8
    // @40
    mut_borrow_loc l8
    mut_borrow_field S, f
    st_loc l9
    copy_loc l9
    read_ref
    // @45
    ld_u64 1
    add
    move_loc l9
    write_ref
    move_loc l8
    // @50
    st_loc l10
    borrow_loc l10
    borrow_field S, f
    read_ref
    st_loc l11
    // @55
    mut_borrow_loc l11
    st_loc l9
    copy_loc l9
    read_ref
    ld_u64 1
    // @60
    add
    move_loc l9
    write_ref
    borrow_loc l10
    borrow_field S, f
    // @65
    read_ref
    st_loc l12
    mut_borrow_loc l12
    st_loc l9
    copy_loc l9
    // @70
    read_ref
    ld_u64 8
    add
    move_loc l9
    write_ref
    // @75
    borrow_loc l10
    borrow_field S, f
    read_ref
    st_loc l13
    mut_borrow_loc l13
    // @80
    st_loc l9
    copy_loc l9
    read_ref
    ld_u64 16
    add
    // @85
    move_loc l9
    write_ref
    borrow_loc l10
    borrow_field S, f
    read_ref
    // @90
    ret
l0: move_loc l1
    st_loc l2
    branch l1

// Function definition at index 3
#[persistent] public fun testb(): u64
    ld_u64 7
    pack S
    call test1b
    ld_u64 2
    pack S
    // @5
    call test1b
    add
    ret



//# run 0x8675::M::test

//# run 0x8675::M::testb