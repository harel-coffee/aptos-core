//**** Cross-compiled for `masm` syntax from `tests/misc/mutate_if.move`

//# publish
// Bytecode version v8
module 0xc0ffee::m
struct S has copy + drop
  x: bool
  y: u64
  z: u64

// Function definition at index 0
fun foo1(l0: S): S
    local l1: u64
    local l2: u64
    local l3: &mut u64
    borrow_loc l0
    borrow_field S, x
    read_ref
    br_false l0
    borrow_loc l0
    // @5
    borrow_field S, y
    read_ref
    st_loc l1
l1: mut_borrow_loc l1
    st_loc l3
    // @10
    ld_u64 2
    move_loc l3
    write_ref
    move_loc l0
    ret
    // @15
l0: borrow_loc l0
    borrow_field S, z
    read_ref
    st_loc l1
    branch l1

// Function definition at index 1
fun foo2(l0: S): S
    local l1: u64
    local l2: u64
    local l3: &mut u64
    ld_u64 2
    st_loc l1
    borrow_loc l0
    borrow_field S, x
    read_ref
    // @5
    br_false l0
    borrow_loc l0
    borrow_field S, y
    read_ref
    st_loc l2
    // @10
l1: mut_borrow_loc l2
    st_loc l3
    move_loc l1
    move_loc l3
    write_ref
    // @15
    move_loc l0
    ret
l0: borrow_loc l0
    borrow_field S, z
    read_ref
    // @20
    st_loc l2
    branch l1

// Function definition at index 2
fun test()
    local l0: S
    local l1: S
    ld_true
    ld_u64 1
    ld_u64 3
    pack S
    st_loc l0
    // @5
    copy_loc l0
    call foo1
    st_loc l1
    move_loc l0
    move_loc l1
    // @10
    eq
    br_false l0
    ld_false
    ld_u64 4
    ld_u64 5
    // @15
    pack S
    st_loc l0
    copy_loc l0
    call foo2
    st_loc l1
    // @20
    move_loc l0
    move_loc l1
    eq
    br_false l1
    ret
    // @25
l1: ld_u64 1
    abort
l0: ld_u64 0
    abort



//# run 0xc0ffee::m::test