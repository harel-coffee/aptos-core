//**** Cross-compiled for `masm` syntax from `tests/misc/freeze_mut_ref.move`

//# publish
// Bytecode version v8
module 0x42::freeze_mut_ref
struct G has drop
  f: u64

// Function definition at index 0
#[persistent] public fun borrow_mut<T0>(l0: &mut vector<T0>): &T0
    move_loc l0
    ld_u64 0
    vec_mut_borrow <T0>
    freeze_ref
    ret

// Function definition at index 1
#[persistent] public fun borrow_mut2<T0>(l0: &mut T0): &T0
    move_loc l0
    freeze_ref
    ret

// Function definition at index 2
fun t1(l0: &mut G): &G
    move_loc l0
    freeze_ref
    ret

// Function definition at index 3
fun t2(l0: &mut u64, l1: &mut u64): (&mut u64, &mut u64)
    move_loc l0
    move_loc l1
    ret

// Function definition at index 4
#[persistent] public fun t5(l0: &mut G): (u64, u64, u64)
    local l1: u64
    local l2: &mut u64
    local l3: u64
    local l4: &mut u64
    local l5: &u64
    local l6: u64
    local l7: u64
    ld_u64 0
    ld_u64 1
    add
    ld_u64 1
    add
    // @5
    st_loc l1
    move_loc l0
    mut_borrow_field G, f
    st_loc l2
    ld_u64 2
    // @10
    st_loc l3
    mut_borrow_loc l3
    st_loc l4
    ld_u64 2
    ld_u64 0
    // @15
    copy_loc l2
    write_ref
    move_loc l4
    freeze_ref
    st_loc l5
    // @20
    copy_loc l2
    write_ref
    move_loc l5
    read_ref
    move_loc l2
    // @25
    read_ref
    move_loc l1
    ret

// Function definition at index 5
fun test_1()
    local l0: u64
    local l1: G
    ld_u64 0
    st_loc l0
    mut_borrow_loc l0
    freeze_ref
    read_ref
    // @5
    ld_u64 0
    eq
    br_false l0
    ld_u64 3
    pack G
    // @10
    st_loc l1
    mut_borrow_loc l1
    call t1
    borrow_field G, f
    read_ref
    // @15
    ld_u64 3
    eq
    br_false l1
    ret
l1: ld_u64 1
    // @20
    abort
l0: ld_u64 0
    abort

// Function definition at index 6
fun test_2()
    local l0: G
    local l1: u64
    local l2: u64
    ld_u64 50
    pack G
    st_loc l0
    mut_borrow_loc l0
    call t5
    // @5
    st_loc l1
    st_loc l2
    ld_u64 2
    eq
    br_false l0
    // @10
    move_loc l2
    ld_u64 2
    eq
    br_false l1
    move_loc l1
    // @15
    ld_u64 2
    eq
    br_false l2
    ret
l2: ld_u64 2
    // @20
    abort
l1: ld_u64 1
    abort
l0: ld_u64 0
    abort

// Function definition at index 7
fun test_3()
    local l0: vector<u64>
    ld_const<vector<u64>> [0]
    st_loc l0
    mut_borrow_loc l0
    call borrow_mut<u64>
    read_ref
    // @5
    ld_u64 0
    eq
    br_false l0
    ret
l0: ld_u64 0
    // @10
    abort

// Function definition at index 8
fun test_5()
    local l0: u64
    ld_u64 3
    st_loc l0
    mut_borrow_loc l0
    call borrow_mut2<u64>
    read_ref
    // @5
    ld_u64 3
    eq
    br_false l0
    ret
l0: ld_u64 0
    // @10
    abort

// Function definition at index 9
fun test_6()
    local l0: G
    local l1: G
    local l2: &G
    ld_u64 2
    pack G
    st_loc l0
    ld_u64 3
    pack G
    // @5
    st_loc l1
    borrow_loc l0
    st_loc l2
l1: move_loc l2
    borrow_field G, f
    // @10
    read_ref
    ld_u64 2
    eq
    br_false l0
    ret
    // @15
l0: ld_u64 0
    abort
    mut_borrow_loc l1
    freeze_ref
    st_loc l2
    // @20
    branch l1

// Function definition at index 10
fun test_7()
    local l0: G
    local l1: G
    local l2: &G
    ld_u64 2
    pack G
    st_loc l0
    ld_u64 3
    pack G
    // @5
    st_loc l1
    borrow_loc l0
    st_loc l2
l1: move_loc l2
    borrow_field G, f
    // @10
    read_ref
    ld_u64 2
    eq
    br_false l0
    ret
    // @15
l0: ld_u64 0
    abort
    mut_borrow_loc l1
    freeze_ref
    st_loc l2
    // @20
    branch l1



//# run 0x42::freeze_mut_ref::test_1

//# run 0x42::freeze_mut_ref::test_2

//# run 0x42::freeze_mut_ref::test_3

//# run 0x42::freeze_mut_ref::test_5

//# run 0x42::freeze_mut_ref::test_6

//# run 0x42::freeze_mut_ref::test_7