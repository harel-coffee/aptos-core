//**** Cross-compiled for `masm` syntax from `tests/inlining/bug_9717.move`

//# publish
// Bytecode version v8
module 0xcafe::vectors
// Function definition at index 0
#[persistent] entry public fun guess_flips(l0: vector<u8>)
    local l1: &vector<u8>
    local l2: u64
    borrow_loc l0
    st_loc l1
    ld_u64 0
    st_loc l2
l2: copy_loc l2
    // @5
    copy_loc l1
    vec_len <u8>
    lt
    br_false l0
    copy_loc l1
    // @10
    copy_loc l2
    vec_borrow <u8>
    read_ref
    ld_u8 0
    neq
    // @15
    br_false l1
    move_loc l1
    pop
l3: ret
l1: move_loc l2
    // @20
    ld_u64 1
    add
    st_loc l2
    branch l2
l0: move_loc l1
    // @25
    pop
    branch l3

// Function definition at index 1
#[persistent] entry public fun guess_flips_directly(l0: vector<u8>)
    local l1: u64
    ld_u64 0
    st_loc l1
l3: copy_loc l1
    borrow_loc l0
    vec_len <u8>
    // @5
    lt
    br_true l0
    branch l1
l0: borrow_loc l0
    copy_loc l1
    // @10
    vec_borrow <u8>
    read_ref
    ld_u8 0
    neq
    br_false l2
    // @15
    branch l1
l1: ret
l2: move_loc l1
    ld_u64 1
    add
    // @20
    st_loc l1
    branch l3

// Function definition at index 2
#[persistent] entry public fun guess_with_break_without_inline(l0: vector<u8>)
    borrow_loc l0
    call loops_with_break_no_inline
    ret

// Function definition at index 3
#[persistent] entry public fun guess_without_break_with_inline(l0: vector<u8>)
    local l1: &vector<u8>
    local l2: u64
    borrow_loc l0
    st_loc l1
    ld_u64 0
    st_loc l2
l2: copy_loc l2
    // @5
    copy_loc l1
    vec_len <u8>
    lt
    br_false l0
    copy_loc l1
    // @10
    copy_loc l2
    vec_borrow <u8>
    read_ref
    ld_u8 0
    eq
    // @15
    br_false l1
    move_loc l2
    ld_u64 1
    add
    st_loc l2
    // @20
    branch l2
l1: move_loc l1
    pop
    ld_u64 3
    abort
    // @25
l0: move_loc l1
    pop
    ret

// Function definition at index 4
fun loops_with_break_no_inline(l0: &vector<u8>)
    local l1: u64
    ld_u64 0
    st_loc l1
l2: copy_loc l1
    copy_loc l0
    vec_len <u8>
    // @5
    lt
    br_false l0
    copy_loc l0
    copy_loc l1
    vec_borrow <u8>
    // @10
    read_ref
    ld_u8 0
    neq
    br_false l1
    move_loc l0
    // @15
    pop
l3: ret
l1: move_loc l1
    ld_u64 1
    add
    // @20
    st_loc l1
    branch l2
l0: move_loc l0
    pop
    branch l3

// Function definition at index 5
fun test_guess_directly()
    ld_const<vector<u8>> [0, 0, 0, 0]
    call guess_flips_directly
    ret

// Function definition at index 6
fun test_guess_with_break_no_inline()
    ld_const<vector<u8>> [0, 0, 0, 0]
    call guess_with_break_without_inline
    ret

// Function definition at index 7
fun test_guess_with_inline_break()
    ld_const<vector<u8>> [0, 0, 0, 0]
    call guess_flips
    ret

// Function definition at index 8
fun test_guess_without_break()
    ld_const<vector<u8>> [0, 0, 0, 0]
    call guess_without_break_with_inline
    ret



//# run 0xcafe::vectors::test_guess_with_inline_break

//# run 0xcafe::vectors::test_guess_directly

//# run 0xcafe::vectors::test_guess_with_break_no_inline

//# run 0xcafe::vectors::test_guess_without_break