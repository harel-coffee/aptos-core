//**** Cross-compiled for `masm` syntax from `tests/no-v1-comparison/fv_as_keys.move`

//# publish
// Bytecode version v8
module 0x99::test_struct
use 0x1::signer
struct Wrapper<T0> has drop + key
  fv: |T0|u64 has copy + drop + store

// Function definition at index 0
#[persistent] public fun init(l0: &signer)
    local l1: |(||u64 has drop + store)|u64 has copy + drop + store
    pack_closure test, 0
    st_loc l1
    move_loc l0
    move_loc l1
    pack Wrapper<||u64 has drop + store>
    // @5
    move_to Wrapper<||u64 has drop + store>
    ret

// Function definition at index 1
#[persistent] fun test(l0: ||u64 has drop + store): u64
    local l1: u64
    move_loc l0
    call_closure <||u64 has drop + store>
    ld_u64 1
    eq
    br_false l0
    // @5
    ld_u64 1
    st_loc l1
l1: move_loc l1
    ret
l0: ld_u64 2
    // @10
    st_loc l1
    branch l1

// Function definition at index 2
#[persistent] fun test1(): u64
    ld_u64 1
    ret

// Function definition at index 3
#[persistent] fun test2(): u64
    ld_u64 2
    ret

// Function definition at index 4
#[persistent] public fun test_bad_borrow_from(l0: &signer) acquires Wrapper
    local l1: &Wrapper<||u64 has copy + drop + store>
    move_loc l0
    call signer::address_of
    borrow_global Wrapper<||u64 has copy + drop + store>
    st_loc l1
    pack_closure test1, 0
    // @5
    copy_loc l1
    borrow_field Wrapper<||u64 has copy + drop + store>, fv
    read_ref
    call_closure <|(||u64 has copy + drop + store)|u64 has copy + drop + store>
    ld_u64 1
    // @10
    eq
    br_false l0
    pack_closure test2, 0
    move_loc l1
    borrow_field Wrapper<||u64 has copy + drop + store>, fv
    // @15
    read_ref
    call_closure <|(||u64 has copy + drop + store)|u64 has copy + drop + store>
    ld_u64 2
    eq
    br_false l1
    // @20
    ret
l1: ld_u64 14566554180833181696
    abort
l0: move_loc l1
    pop
    // @25
    ld_u64 14566554180833181696
    abort

// Function definition at index 5
#[persistent] public fun test_bad_move_from(l0: &signer) acquires Wrapper
    move_loc l0
    call signer::address_of
    move_from Wrapper<||u64 has copy + drop + store>
    pop
    ret

// Function definition at index 6
#[persistent] public fun test_borrow_from(l0: &signer) acquires Wrapper
    local l1: &Wrapper<||u64 has drop + store>
    move_loc l0
    call signer::address_of
    borrow_global Wrapper<||u64 has drop + store>
    st_loc l1
    pack_closure test1, 0
    // @5
    copy_loc l1
    borrow_field Wrapper<||u64 has drop + store>, fv
    read_ref
    call_closure <|(||u64 has drop + store)|u64 has copy + drop + store>
    ld_u64 1
    // @10
    eq
    br_false l0
    pack_closure test2, 0
    move_loc l1
    borrow_field Wrapper<||u64 has drop + store>, fv
    // @15
    read_ref
    call_closure <|(||u64 has drop + store)|u64 has copy + drop + store>
    ld_u64 2
    eq
    br_false l1
    // @20
    ret
l1: ld_u64 14566554180833181696
    abort
l0: move_loc l1
    pop
    // @25
    ld_u64 14566554180833181696
    abort

// Function definition at index 7
#[persistent] public fun test_exist(l0: &signer)
    move_loc l0
    call signer::address_of
    exists Wrapper<||u64 has drop + store>
    br_false l0
    ret
    // @5
l0: ld_u64 14566554180833181696
    abort

// Function definition at index 8
#[persistent] public fun test_move_from(l0: &signer) acquires Wrapper
    move_loc l0
    call signer::address_of
    move_from Wrapper<||u64 has drop + store>
    pop
    ret

// Function definition at index 9
#[persistent] public fun test_not_exist_1(l0: &signer)
    move_loc l0
    call signer::address_of
    exists Wrapper<u64>
    br_true l0
    ret
    // @5
l0: ld_u64 14566554180833181696
    abort

// Function definition at index 10
#[persistent] public fun test_not_exist_2(l0: &signer)
    move_loc l0
    call signer::address_of
    exists Wrapper<||u64 has store>
    br_true l0
    ret
    // @5
l0: ld_u64 14566554180833181696
    abort

// Function definition at index 11
#[persistent] public fun test_not_exist_3(l0: &signer)
    move_loc l0
    call signer::address_of
    exists Wrapper<||u64 has copy + drop + store>
    br_true l0
    ret
    // @5
l0: ld_u64 14566554180833181696
    abort



//# run --verbose --signers 0x1 -- 0x99::test_struct::init

//# run --verbose --signers 0x1 -- 0x99::test_struct::test_exist

//# run --verbose --signers 0x1 -- 0x99::test_struct::test_not_exist_1

//# run --verbose --signers 0x1 -- 0x99::test_struct::test_not_exist_2

//# run --verbose --signers 0x1 -- 0x99::test_struct::test_not_exist_3

//# run --verbose --signers 0x1 -- 0x99::test_struct::test_bad_borrow_from

//# run --verbose --signers 0x1 -- 0x99::test_struct::test_borrow_from

//# run --verbose --signers 0x1 -- 0x99::test_struct::test_bad_move_from

//# run --verbose --signers 0x1 -- 0x99::test_struct::test_move_from

//# run --verbose --signers 0x1 -- 0x99::test_struct::test_borrow_from

//# publish
// Bytecode version v8
module 0x99::test_enum
use 0x1::signer
enum Wrapper<T0> has key
  V1
    fv1: |T0|u64 has copy + store
  V2
    fv1: |T0|u64 has copy + drop + store

// Function definition at index 0
#[persistent] public fun init(l0: &signer)
    local l1: Wrapper<||u64 has drop + store>
    pack_closure test, 0
    pack_variant Wrapper<||u64 has drop + store>, V1
    st_loc l1
    move_loc l0
    move_loc l1
    // @5
    move_to Wrapper<||u64 has drop + store>
    ret

// Function definition at index 1
#[persistent] public fun bad_init(l0: &signer)
    local l1: Wrapper<||u64 has drop + store>
    pack_closure test, 0
    pack_variant Wrapper<||u64 has drop + store>, V2
    st_loc l1
    move_loc l0
    move_loc l1
    // @5
    move_to Wrapper<||u64 has drop + store>
    ret

// Function definition at index 2
#[persistent] fun test(l0: ||u64 has drop + store): u64
    local l1: u64
    move_loc l0
    call_closure <||u64 has drop + store>
    ld_u64 1
    eq
    br_false l0
    // @5
    ld_u64 1
    st_loc l1
l1: move_loc l1
    ret
l0: ld_u64 2
    // @10
    st_loc l1
    branch l1

// Function definition at index 3
#[persistent] fun test1(): u64
    ld_u64 1
    ret

// Function definition at index 4
#[persistent] fun test2(): u64
    ld_u64 2
    ret

// Function definition at index 5
#[persistent] public fun test_bad_borrow_from(l0: &signer) acquires Wrapper
    local l1: &Wrapper<||u64 has copy + drop + store>
    move_loc l0
    call signer::address_of
    borrow_global Wrapper<||u64 has copy + drop + store>
    pop
    ret

// Function definition at index 6
#[persistent] public fun test_bad_move_from(l0: &signer) acquires Wrapper
    local l1: Wrapper<||u64 has copy + drop + store>
    local l2: &Wrapper<||u64 has copy + drop + store>
    local l3: |(||u64 has copy + drop + store)|u64 has copy + store
    local l4: u64
    local l5: |(||u64 has copy + drop + store)|u64 has copy + drop + store
    move_loc l0
    call signer::address_of
    move_from Wrapper<||u64 has copy + drop + store>
    st_loc l1
    borrow_loc l1
    // @5
    st_loc l2
    copy_loc l2
    test_variant Wrapper<||u64 has copy + drop + store>, V1
    br_false l0
    move_loc l2
    // @10
    pop
    move_loc l1
    unpack_variant Wrapper<||u64 has copy + drop + store>, V1
    st_loc l3
    pack_closure test1, 0
    // @15
    move_loc l3
    call_closure <|(||u64 has copy + drop + store)|u64 has copy + store>
    st_loc l4
l3: move_loc l4
    ld_u64 1
    // @20
    eq
    br_false l1
    ret
l1: ld_u64 0
    abort
    // @25
l0: move_loc l2
    test_variant Wrapper<||u64 has copy + drop + store>, V2
    br_false l2
    move_loc l1
    unpack_variant Wrapper<||u64 has copy + drop + store>, V2
    // @30
    st_loc l5
    pack_closure test2, 0
    move_loc l5
    call_closure <|(||u64 has copy + drop + store)|u64 has copy + drop + store>
    st_loc l4
    // @35
    branch l3
l2: ld_u64 14566554180833181697
    abort

// Function definition at index 7
#[persistent] public fun test_borrow_from(l0: &signer) acquires Wrapper
    local l1: &Wrapper<||u64 has drop + store>
    local l2: &|(||u64 has drop + store)|u64 has copy + store
    local l3: u64
    local l4: &|(||u64 has drop + store)|u64 has copy + drop + store
    move_loc l0
    call signer::address_of
    borrow_global Wrapper<||u64 has drop + store>
    st_loc l1
    copy_loc l1
    // @5
    test_variant Wrapper<||u64 has drop + store>, V1
    br_false l0
    move_loc l1
    borrow_variant_field Wrapper<||u64 has drop + store>, V1::fv1
    st_loc l2
    // @10
    pack_closure test1, 0
    move_loc l2
    read_ref
    call_closure <|(||u64 has drop + store)|u64 has copy + store>
    st_loc l3
    // @15
l3: move_loc l3
    ld_u64 1
    eq
    br_false l1
    ret
    // @20
l1: ld_u64 0
    abort
l0: copy_loc l1
    test_variant Wrapper<||u64 has drop + store>, V2
    br_false l2
    // @25
    move_loc l1
    borrow_variant_field Wrapper<||u64 has drop + store>, V2::fv1
    st_loc l4
    pack_closure test2, 0
    move_loc l4
    // @30
    read_ref
    call_closure <|(||u64 has drop + store)|u64 has copy + drop + store>
    st_loc l3
    branch l3
l2: move_loc l1
    // @35
    pop
    ld_u64 14566554180833181697
    abort

// Function definition at index 8
#[persistent] public fun test_exist(l0: &signer)
    move_loc l0
    call signer::address_of
    exists Wrapper<||u64 has drop + store>
    br_false l0
    ret
    // @5
l0: ld_u64 14566554180833181696
    abort

// Function definition at index 9
#[persistent] public fun test_move_from(l0: &signer) acquires Wrapper
    local l1: Wrapper<||u64 has drop + store>
    local l2: &Wrapper<||u64 has drop + store>
    local l3: |(||u64 has drop + store)|u64 has copy + store
    local l4: u64
    local l5: |(||u64 has drop + store)|u64 has copy + drop + store
    move_loc l0
    call signer::address_of
    move_from Wrapper<||u64 has drop + store>
    st_loc l1
    borrow_loc l1
    // @5
    st_loc l2
    copy_loc l2
    test_variant Wrapper<||u64 has drop + store>, V1
    br_false l0
    move_loc l2
    // @10
    pop
    move_loc l1
    unpack_variant Wrapper<||u64 has drop + store>, V1
    st_loc l3
    pack_closure test1, 0
    // @15
    move_loc l3
    call_closure <|(||u64 has drop + store)|u64 has copy + store>
    st_loc l4
l3: move_loc l4
    ld_u64 1
    // @20
    eq
    br_false l1
    ret
l1: ld_u64 0
    abort
    // @25
l0: move_loc l2
    test_variant Wrapper<||u64 has drop + store>, V2
    br_false l2
    move_loc l1
    unpack_variant Wrapper<||u64 has drop + store>, V2
    // @30
    st_loc l5
    pack_closure test2, 0
    move_loc l5
    call_closure <|(||u64 has drop + store)|u64 has copy + drop + store>
    st_loc l4
    // @35
    branch l3
l2: ld_u64 14566554180833181697
    abort

// Function definition at index 10
#[persistent] public fun test_not_exist_1(l0: &signer)
    move_loc l0
    call signer::address_of
    exists Wrapper<u64>
    br_true l0
    ret
    // @5
l0: ld_u64 14566554180833181696
    abort

// Function definition at index 11
#[persistent] public fun test_not_exist_2(l0: &signer)
    move_loc l0
    call signer::address_of
    exists Wrapper<||u64 has store>
    br_true l0
    ret
    // @5
l0: ld_u64 14566554180833181696
    abort

// Function definition at index 12
#[persistent] public fun test_not_exist_3(l0: &signer)
    move_loc l0
    call signer::address_of
    exists Wrapper<||u64 has copy + drop + store>
    br_true l0
    ret
    // @5
l0: ld_u64 14566554180833181696
    abort



//# run --verbose --signers 0x1 -- 0x99::test_enum::init

//# run --verbose --signers 0x1 -- 0x99::test_enum::bad_init

//# run --verbose --signers 0x1 -- 0x99::test_enum::test_exist

//# run --verbose --signers 0x1 -- 0x99::test_enum::test_not_exist_1

//# run --verbose --signers 0x1 -- 0x99::test_enum::test_not_exist_2

//# run --verbose --signers 0x1 -- 0x99::test_enum::test_not_exist_3

//# run --verbose --signers 0x1 -- 0x99::test_enum::test_bad_borrow_from

//# run --verbose --signers 0x1 -- 0x99::test_enum::test_borrow_from

//# run --verbose --signers 0x1 -- 0x99::test_enum::test_bad_move_from

//# run --verbose --signers 0x1 -- 0x99::test_enum::test_move_from

//# run --verbose --signers 0x1 -- 0x99::test_enum::test_move_from