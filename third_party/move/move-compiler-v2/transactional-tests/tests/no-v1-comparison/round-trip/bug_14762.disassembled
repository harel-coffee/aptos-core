//**** Cross-compiled for `masm` syntax from `tests/no-v1-comparison/bug_14762.move`

//# publish
// Bytecode version v8
module 0x42::m
use 0x1::option
use 0x1::vector
struct T has copy + drop + store
  issuer: vector<u8>
  version: u64

struct J has copy + drop + store
  variant: u64

struct S has copy + drop + store
  entries: vector<T>

// Function definition at index 0
fun test(l0: &mut S, l1: vector<u8>): option::Option<T>
    local l2: &vector<T>
    local l3: bool
    local l4: u64
    local l5: u64
    local l6: u64
    local l7: u64
    local l8: option::Option<T>
    copy_loc l0
    borrow_field S, entries
    st_loc l2
    ld_false
    st_loc l3
    // @5
    ld_u64 0
    st_loc l4
    ld_u64 0
    st_loc l5
    copy_loc l2
    // @10
    vec_len <T>
    st_loc l6
l5: copy_loc l5
    copy_loc l6
    lt
    // @15
    br_true l0
    branch l1
l0: copy_loc l2
    copy_loc l5
    vec_borrow <T>
    // @20
    borrow_field T, issuer
    read_ref
    copy_loc l1
    eq
    br_false l2
    // @25
    ld_true
    st_loc l3
    move_loc l5
    st_loc l4
l1: nop
    // @30
    move_loc l2
    pop
    move_loc l3
    move_loc l4
    st_loc l7
    // @35
    br_false l3
    move_loc l0
    mut_borrow_field S, entries
    move_loc l7
    call vector::remove<T>
    // @40
    call option::some<T>
    st_loc l8
l4: move_loc l8
    ret
l3: move_loc l0
    // @45
    pop
    call option::none<T>
    st_loc l8
    branch l4
l2: move_loc l5
    // @50
    ld_u64 1
    add
    st_loc l5
    branch l5

// Function definition at index 1
fun test1()
    local l0: T
    local l1: T
    local l2: S
    local l3: option::Option<T>
    local l4: option::Option<T>
    local l5: option::Option<T>
    ld_const<vector<u8>> [1]
    ld_u64 1
    pack T
    ld_const<vector<u8>> [2]
    ld_u64 0
    // @5
    pack T
    vec_pack <T>, 2
    pack S
    st_loc l2
    mut_borrow_loc l2
    // @10
    ld_const<vector<u8>> [0]
    call test
    st_loc l3
    borrow_loc l3
    call option::is_none<T>
    // @15
    br_false l0
    mut_borrow_loc l2
    ld_const<vector<u8>> [1]
    call test
    st_loc l4
    // @20
    borrow_loc l4
    call option::is_some<T>
    br_false l1
    borrow_loc l4
    call option::borrow<T>
    // @25
    borrow_field T, issuer
    read_ref
    ld_const<vector<u8>> [1]
    eq
    br_false l2
    // @30
    mut_borrow_loc l2
    ld_const<vector<u8>> [2]
    call test
    st_loc l5
    borrow_loc l5
    // @35
    call option::is_some<T>
    br_false l3
    borrow_loc l5
    call option::borrow<T>
    borrow_field T, issuer
    // @40
    read_ref
    ld_const<vector<u8>> [2]
    eq
    br_false l4
    ret
    // @45
l4: ld_u64 0
    abort
l3: ld_u64 0
    abort
l2: ld_u64 0
    // @50
    abort
l1: ld_u64 0
    abort
l0: ld_u64 0
    abort



//# run 0x42::m::test1